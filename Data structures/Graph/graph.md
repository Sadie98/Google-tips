Граф - абстрактное представление множества объектов и связей между ними. 

Графом называют пару (V, E), где V - множество вершин, E - множество рёбер (множество пар, каждая из которых представляет собой связь).

Граф:
+ ориентированный
+ неориентированный

Степень - бывает входящая и исходящая.

Путь в графе это конечная последовательность вершин, в которой каждые две вершины идущие подряд соединены ребром.

Представляется:
+ матрицей смежности
+ списком смежности
+ множеством смежности

# Списки

В множестве скорость вставки и получения O(1):
```python
a, b, c, d, e, f, g, h = range(8)
N = [
	{b, c, d, e, f}, # a
	{c, e}, # b
	{d}, # c
	{e}, # d
	{f}, # e
	{c, g, h}, # f
	{f, h}, # g
	{f, g} # h
]
```
 
В списке O(n):
```python
a, b, c, d, e, f, g, h = range(8)
N = [
	[b, c, d, e, f], # a
	[c, e], # b
	[d], # c
	[e], # d
	[f], # e
	[c, g, h], # f
	[f, h], # g
	[f, g] # h
]
```

Если все, что делает ваш алгоритм — это обход соседних вершин, то использование объектов типа множество не просто бессмысленно: накладные расходы могут ухудшить постоянные множители в асимптотике вашей реализации

Список хорош для эффективного обхода вершины.  
Проверка на то, являются ли вершины смежными, долгая, тут лучше множества смежности.

_Совет:
Известно, что удаление объектов из середины list в Python довольно затратно. Удаление с конца при этом происходит за константное время. Если вы не заботитесь о порядке вершин, то можете удалять случайную вершину за константное время перезаписывая ее той, что находится в конце списка смежности, и вызывая затем метод pop._

Вместо множества можно использовать словарь. Тогда туда поместятся ещё и веса.

Норм вариант - чисто словарь.
```python
N = {  
	'a': set('bcdef'),  
	'b': set('ce'),  
	'c': set('d'),
	'd': set('e'),
	'e': set('f'),
	'f': set('cgh'),
	'g': set('fh'),
	'h': set('fg')
}
```

# Матрица
```python

a, b, c, d, e, f, g, h = range(8)
# a b c d e f g h
N =  [[0,1,1,1,1,1,0,0], # a
	 [0,0,1,0,1,0,0,0], # b
	 [0,0,0,1,0,0,0,0], # c
	 [0,0,0,0,1,0,0,0], # d
	 [0,0,0,0,0,1,0,0], # e
	 [0,0,1,0,0,0,1,1], # f
	 [0,0,0,0,0,1,0,1], # g
	 [0,0,0,0,0,1,1,0]] # h
```
_Ненаправленные графы обычно описываются парами ребер в обоих направлениях. Это значит, что матрица смежности для ненаправленного графа будет симметричной._  
Сложность вычисления степени тут Θ(n), в то время как в другом представлении и смежность, и степень вершины можно определить за константное время.

```python
N = [[0]*10 for i in range(10)]
```